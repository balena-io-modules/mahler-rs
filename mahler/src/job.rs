//! Types for creating and manipulating Worker Jobs

use std::cmp::Ordering;

use crate::json::OperationMatcher;
use crate::runtime::Context;
use crate::task::{Description, Handler, Id, Task};

/// Encodes a generic repeatable system operation
///
/// A Job is the generic type used by the [Worker](`crate::worker::Worker`) to create the specific
/// tasks that form a Workflow generated by the planning step.
///
/// A `Job` is created from a [`Handler`](`crate::task::Handler`) and an [Operation](`crate::json::Operation`). During planning, the operation
/// is used to determine the applicability of a job to a state change.
#[derive(Debug, Clone)]
pub struct Job {
    operation: OperationMatcher,
    task: Task,
}

impl Job {
    pub(crate) fn new(task: Task, operation: OperationMatcher) -> Self {
        Job { operation, task }
    }

    /// Get the unique identifier for the job
    pub fn id(&self) -> Id {
        self.task.id()
    }

    /// Get the operation assigned to the job
    pub fn operation(&self) -> &OperationMatcher {
        &self.operation
    }

    /// Set a human readable description for the Job
    ///
    /// A [description](`crate::task::Description`) is any function that accepts zero or more context
    /// extractors and returns a String. A context extractor is a type that implements
    /// [FromContext](`crate::runtime::FromContext`)
    ///
    /// The description will be used to describe the tasks used by the crate
    /// [observability features](`crate#observability`) and for human readable logs
    ///
    /// ```rust
    /// use mahler::job::{Job, update};
    /// use mahler::extract::Args;
    ///
    /// fn foo() {}
    ///
    /// let job = update(foo).with_description(|Args(foo): Args<String>| format!("a job for {foo}!"));
    /// ```
    pub fn with_description<D, T>(mut self, description: D) -> Self
    where
        D: Description<T>,
    {
        self.task = self.task.with_description(description);
        self
    }

    /// Create a new task from the Job and the given Context
    pub(crate) fn new_task(&self, context: Context) -> Task {
        self.task.clone().with_context(context)
    }
}

macro_rules! define_job {
    ($func_name:ident, $operation:expr) => {
        #[doc = concat!("Create a new `Job` for the [`", stringify!($operation), "`] operation.")]
        pub fn $func_name<H, T, O, I>(handler: H) -> Job
        where
            H: Handler<T, O, I>,
            I: 'static,
        {
            Job::new(handler.into_task(), $operation)
        }
    };
}

define_job!(create, OperationMatcher::Create);
define_job!(update, OperationMatcher::Update);
define_job!(delete, OperationMatcher::Delete);
define_job!(any, OperationMatcher::Any);
define_job!(none, OperationMatcher::None);

impl PartialEq for Job {
    fn eq(&self, other: &Self) -> bool {
        self.task.id() == other.task.id() && self.operation == other.operation
    }
}
impl Eq for Job {}

impl PartialOrd for Job {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for Job {
    fn cmp(&self, other: &Self) -> Ordering {
        self.id()
            .cmp(&other.id())
            .then(self.operation.cmp(&other.operation))
    }
}
